{"pages":[{"title":"我们","text":"鼎阅Android团队","link":"/about/index.html"}],"posts":[{"title":"build:gradle 3.0 以及 Support Library 27.1.0 带来的 Api 变动","text":"Google 又双叒升级了 Android 的开发库，我们将根目录下的 build:gradle 版本由原先的 2.3.3 升级至 3.1.2，随之带来的问题是 Support Library 也需要升级。升级之后，gradle 脚本以及 support 包下相关类的 Api 发生了重大的改动。具体需要注意的改动如下： build.gradle 文件引入依赖的方式由原来的 compile 变更为现在的 implementation 和 api 关键字，这两个关键字的区别在于是否能传递依赖，例如： 注意：使用旧的关键字 compile 进行依赖应用并不会报错，只会报警告。使用 implementation 可以提升编译速度。 Support Library 27新的 support 包带来便捷的新特性，如自带生命周期组件中的 android.arch.lifecycle:runtime 库，但对现有代码对兼容带来不小的麻烦。 ⚠️最明显的变化就是 Fragment 中的 getActivity() 以及 getContext() 方法返回的被标记为 @Nullable, 也就是返回值可能为 null , 于是在 Kotlin 中所有获取 Activity、Context 实例的地方都需要判空操作。 其实 Google 并没有更改代码逻辑，返回 null 是因为 fragment 没有加入到 actiivty 中，这个逻辑处理之前的版本就存在，只是相比之前加上 @Nullable 注解，具体可以看这里的解释：https://stackoverflow.com/a/49289578/7077907 。 如何更好的兼容之前的代码？直接加 !! 处理是没有问题的，如果你觉得这样写过于丑陋并且看起来十分危险，可以用 activity ? : return 这样的写法代替，或者更好的方式是使用 Google 新提供的方法： 12requireActivity()requireContext() 这两个方法的返回值是不为 null 的，内部作了判空抛异常处理。具体文档可看源码或这里：https://developer.android.com/topic/libraries/support-library/revisions#27-1-0 以上。","link":"/2018/09/03/new-api-in-gradle-3-0-and-support-library-27-1-0/"},{"title":"Hello World","text":"Hello, World !Hello, Hexo ! 你好。","link":"/2018/09/03/hello-world/"},{"title":"我们眼中 RxJava 式的网络请求","text":"诞生 5 年之久的 RxJava，已经不只是一个开源库，可以说它的诞生改变了我们写代码的方式，把它比作「神兵利器」也毫不为过。我们现在已经能看到各式各样名为「最佳实践」的使用教程，如果我们没能用好这把利器，不仅不会发挥它的作用，反而会伤着我们自己。 回顾它的诞生原因，是为了解决回调地狱 (callback hell) 以及麻烦的线程切换。在 Android 开发中，哪个地方最会出现多层的回调嵌套以及频繁的线程切换呢？对！没错！是「网络请求」。所以 RxJava、Retrofit 这俩兄弟总会一起出现的，我们项目中关于 RxJava 的使用，也几乎都和网络请求相关。 过去的经验最初我们对 RxJava + Retrofit 的使用经验都是来源于 RxJava 与 Retrofit 结合的最佳实践 这篇文章，相信大家都看过。这篇文章中的基本封装思想是：订阅每个网络请求的流，将流的订阅结果再通过回调的方式返给流（也就是网络请求）的创建者。 如下所示： 12345678910111213141516171819202122232425262728293031//HttpMethodpublic void getTopMovie(final ResultListener listener, int start, int count)&#123; movieService.getTopMovie(start, count) .subscribeOn(Schedulers.io()) .unsubscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber()&#123; @Override public void onStart() &#123;&#125; @Override public void onNext(Subject t) &#123; listener.onNext(t) &#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onCompleted() &#123;&#125; &#125;)&#125;//ActivityHttpMethods.getInstance().getTopMovie(new ResultListener()&#123; @Override public void onNext(Subject t)&#123; //handle result &#125;&#125;, 0, 10) 有什么问题？这种封装方式，对于初步的使用以及简单的项目，是没有问题的。但是遇到复杂一点的网络请求，它的扩展性就不那么灵活了： 多个连续的网络请求怎么写？按照上面的那种封装方式，我们有两种选择 拆解这个请求，在 subscribe 之前通过 flatMap 发起第二个或者第三个网络请求。这种写法肯定会影响项目中已有的外部调用。 在 onNext 中发起第二个请求，再在第二个网络请求的 onNext 中发起第三个网络请求……这一层又一层的回调嵌套，正是用 RxJava 所能解决、避免的这样写，我们就又回到了最初的原点。 怎么取消网络请求？不取消，意味着内存泄露的风险。 回到 RxJava 本身RxJava 提供给我们的、我们所中意的强大之处在哪？在于它的「操作符」，map、flatMap、zip 等等，甚至线程的切换 subscribeOn、observeOn 也是操作符。RxJava 的各种强大的功能就是通过各式各样的「操作符」实现的。 操作符操作的是什么？流。流（Observable、Flowable）是 RxJava 的基本单位。所以一套链式请求拆开应该是这样的： 所以说，网络请求库对外提供网络请求的结果应该是以「流」的形式进行提供： 单个网络请求，对外提供单个「流」 多个网络请求，将多个网络请求结果流通过「操作符」组合成一个「流」对外提供 持久化：网络请求结果流和持久化的缓存流，总能通过「操作符」组合成一个对外提供的结果「流」 我们需要背压吗？当生产者大于消费者，则市场价格会降低，则会产生背压问题（Backpressure）。解决背压有很多种策略，RxJava2 中的 Flowable 天然支持背压。所以 Flowable 这个万金油，不管三七二十一，直接拿来用是没有问题的。 但是，网络请求，会产生背压问题吗？不会，为了防止抬杠，可以说大部分情况下是不会的。网络请求的每一个流，即用即走，上游的生产者（Request）和下游的消费者(Responese)，永远是一对一的关系，不会出现连续的事件流。杀鸡焉用牛刀，所以我们可以退一步，改用 Observable。 网络请求不会出现连续的事件流，在 onNext 出现之后，onComplete 马上就会被调用，所以只需要这两者中的一个就够了，也就不用考虑 Observable，同样 Maybe 也是可以排除的。 剩下的也就只有 Single 和 Completable 了，相对于 Single，Completable 没有 map 和 flatMap 方法。所以需要进一步处理网络请求结果的我们，可以选择使用 Single。 抛出异常网络请求过程，协议层的异常会自动抛至 onError() ，如 404、503 错误。对于如下有请求结果但无目标请求数据，我们也应当作为异常来处理： 1234&#123; \"code\": \"6002\", \"msg\": \"公钥为空\"&#125; 毕竟这样的请求结果，是后端经过异常处理返回给我们的。 假定我们的请求结果是这样的范式： 12345data CommonResult&lt;T&gt;( var code: Int = 0, var data: T? = null, var message: String? = null) 我们活用 RxJava 的操作符，用 map 来处理请求到的 ResponseBody (这也是前面选择 Single 的原因)，为了便于复用，可以定义一个这样的 mapper: 1234567891011class CommonResultMapper&lt;T&gt; : Function&lt;CommonResult&lt;T&gt;, T&gt; &#123; override fun apply(t: CommonResult&lt;T&gt;): T &#123; val data = t.data if (t.code == SUCCESS_CODE &amp;&amp; data != null) &#123; return data &#125; else &#123; //抛出异常 throw Throwable(\"请求 $t 失败\") &#125; &#125;&#125; 使用这个定义好的 mapper： 123456789@GET(PUSH_URL)fun fetchTag(@Query(\"udid\") udid: String): Single&lt;CommonResult&lt;Tag&gt;&gt;fun fetchTagResult(udid: String): Single&lt;Tag&gt; &#123; return netService.fetchTag(udid) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(CommonResultMapper())&#125; 如果你愿意，你还可以将线程切换和数据处理结合在一起，使用 RxJava 的 Transformer 1234567891011121314//定义一个 transformerfun &lt;T&gt; resultTransformer(): SingleTransformer&lt;CommonResult&lt;T&gt;, T&gt; &#123; return SingleTransformer &#123; single -&gt; single.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(CommonResultMapper()) &#125;&#125;//使用fun fetchTagResult(udid: String): Single&lt;Tag&gt; &#123; return netService.fetchTag(udid) .compose(resultTransformer())&#125; 使用这样封装，结果归结果，异常归异常。 123456789fetchTagResult(\"123321\") .subscribeBy( onSuccess = &#123; tag -&gt; //结果 &#125;, onError = &#123; e -&gt; //异常 &#125; ) 回顾上图中的对内封装和对外可见，在得到真正想要的网络请求结果之前，需要一直保持对内封装的状态。因此，如果需要同时或者按顺序发起多个网络请求，那么就应该在对内封装中进行操作，例如可以使用 flatMap 按顺序发起第二个网络请求： 123456789101112fun fetchUserSingle(tag: Tag): Single&lt;User&gt; &#123; return netService.fetchUser(tag)&#125;fun fetchUserResult(udid: String): Single&lt;User&gt; &#123; return netService.fetchTag(udid) .compose(resultTransformer()) .flatMap&#123; tag -&gt; //使用第一个请求的结果作为第二个请求的参数 return@flatMap fetchUserSingle(tag) &#125;&#125; 无论如何，善用操作符，我们的代码总会是「链式」的。 取消网络请求与内存泄漏最后还需要关注一下这里的内存泄漏问题，在 Activity 销毁时，要及时取消掉这些已经失去上下文意义的网络请求。这里我们及时 unsubscribe 就好了。 同时在管理生命周期方面，也有更成熟的方案：RxLifecycle。 以上","link":"/2019/02/23/best-practice-in-rxjava-network-method/"}],"tags":[{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"网络","slug":"网络","link":"/tags/网络/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/其他/"}]}